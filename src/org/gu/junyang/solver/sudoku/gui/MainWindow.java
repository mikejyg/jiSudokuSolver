/**
 * Copyright (C) 2011 Junyang Gu <mikejyg@gmail.com>
 * 
 * This file is part of iSudokuSolver.
 *
 * iSudokuSolver is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * iSudokuSolver is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with iSudokuSolver.  If not, see <http://www.gnu.org/licenses/>.
 */

package org.gu.junyang.solver.sudoku.gui;

import java.awt.Component;
import java.awt.Cursor;
import java.awt.Point;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.awt.print.PageFormat;
import java.awt.print.PrinterException;
import java.awt.print.PrinterJob;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Properties;
import java.util.Scanner;
import java.util.logging.Level;
import javax.swing.JDialog;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.JTextArea;
import org.apache.log4j.Logger;
import org.apache.log4j.PropertyConfigurator;
import org.gu.junyang.solver.sudoku.Board;
import org.gu.junyang.solver.sudoku.Puzzle;
import org.gu.junyang.solver.sudoku.SolverFactory;
import org.gu.junyang.solver.sudoku.SolverNonGreedy;
import org.gu.junyang.solver.sudoku.Puzzle.UnexpectedEndOfInputException;
import org.gu.junyang.solver.sudoku.Sudoku;
import org.gu.junyang.solver.sudoku.Sudoku.SolveResult;
import org.gu.junyang.utilities.ArrayListUtils;
import org.gu.junyang.utilities.ExceptionUtils;
import org.gu.junyang.utilities.MessagePoster;
import org.gu.junyang.utilities.ProgramErrorException;

/**
 *
 */
public class MainWindow extends javax.swing.JFrame implements MessagePoster {

    Logger logger = Logger.getLogger(this.getClass());
    static public final String NL = System.getProperty("line.separator");

    boolean instantSolvabilityCheck = true;

    // the transcript window
    TextAreaDialog transcriptWindow;

    // properties of this application, used to save and restore setting upon restart
    Properties properties = new Properties();

    public static final String PROPERTIES_FILE_NAME = "jisudokusolver.properties";
    private String propertiesFileFullPathName;
    
    public static final String windowName = "mainWindow";

    /** Creates new form MainWindow */
    public MainWindow() {

    	propertiesFileFullPathName = System.getProperty("user.home") + System.getProperty("file.separator") 
    		+ PROPERTIES_FILE_NAME; 
    	
//    	logger.info("properties file: " + propertiesFileFullPathName);
    	System.err.println("using properties file: " + propertiesFileFullPathName);
    	
        initComponents();

        readProperties();

        customInitComponents();

    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        tabbedPane = new javax.swing.JTabbedPane();
        inputPanel = new org.gu.junyang.solver.sudoku.gui.BoardPanel();
        solutionPanel = new org.gu.junyang.solver.sudoku.gui.BoardPanel();
        guessPanel = new org.gu.junyang.solver.sudoku.gui.BoardPanel();
        fixedPanel = new org.gu.junyang.solver.sudoku.gui.BoardPanel();
        reducedPanel = new org.gu.junyang.solver.sudoku.gui.BoardPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextAreaMessages = new javax.swing.JTextArea();
        statusLabel = new javax.swing.JLabel();
        boardIndexLabel = new javax.swing.JLabel();
        jButtonBack = new javax.swing.JButton();
        jButtonForward = new javax.swing.JButton();
        jMenuBar1 = new javax.swing.JMenuBar();
        jMenuFile = new javax.swing.JMenu();
        jMenuItemNew = new javax.swing.JMenuItem();
        jMenuItemOpen = new javax.swing.JMenuItem();
        jMenuItemSave = new javax.swing.JMenuItem();
        jMenuItemGenerate = new javax.swing.JMenuItem();
        jMenuItemGenerateFromInput = new javax.swing.JMenuItem();
        PrintMenuItem = new javax.swing.JMenuItem();
        viewMenu = new javax.swing.JMenu();
        showCandidatesMenuItem = new javax.swing.JCheckBoxMenuItem();
        jCheckBoxMenuItemViewTranscript = new javax.swing.JCheckBoxMenuItem();
        highlightChangesCheckBoxMenuItem = new javax.swing.JCheckBoxMenuItem();
        jMenuEdit = new javax.swing.JMenu();
        jMenuItemCopy = new javax.swing.JMenuItem();
        jMenuItemPaste = new javax.swing.JMenuItem();
        jMenuSolver = new javax.swing.JMenu();
        jMenuItemSolve = new javax.swing.JMenuItem();
        jMenuItemCrossEliminate = new javax.swing.JMenuItem();
        singleDestinationMenuItem = new javax.swing.JMenuItem();
        jMenuItemReduce = new javax.swing.JMenuItem();
        fixConflictMenuItem = new javax.swing.JMenuItem();
        checkSolvabilityMenuItem = new javax.swing.JMenuItem();
        jMenuStep = new javax.swing.JMenu();
        jMenuItemStepBack = new javax.swing.JMenuItem();
        jMenuItemStepForward = new javax.swing.JMenuItem();
        jMenuItemGotoStep = new javax.swing.JMenuItem();
        advancedMenu = new javax.swing.JMenu();
        solverRandomSearchCheckBox = new javax.swing.JCheckBoxMenuItem();
        hintMenu = new javax.swing.JMenu();
        instantSolvabilityCheckCheckBox = new javax.swing.JCheckBoxMenuItem();
        jMenuItem1 = new javax.swing.JMenuItem();
        helpMenu = new javax.swing.JMenu();
        helpMenuItem = new javax.swing.JMenuItem();
        aboutMenuItem = new javax.swing.JMenuItem();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Java Intelligent Sudoku Solver");
        setMinimumSize(new java.awt.Dimension(640, 590));
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent evt) {
                formWindowClosing(evt);
            }
        });

        tabbedPane.setFocusable(false);
        tabbedPane.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                tabbedPaneStateChanged(evt);
            }
        });

        inputPanel.setLayout(new java.awt.GridLayout(3, 3));
        tabbedPane.addTab("input", inputPanel);

        solutionPanel.setLayout(new java.awt.GridLayout(3, 3));
        tabbedPane.addTab("solution", solutionPanel);
        tabbedPane.addTab("guessed values", guessPanel);
        tabbedPane.addTab("fixed", fixedPanel);
        tabbedPane.addTab("redued", reducedPanel);

        jScrollPane1.setBorder(javax.swing.BorderFactory.createTitledBorder("messages"));

        jTextAreaMessages.setColumns(20);
        jTextAreaMessages.setRows(5);
        jScrollPane1.setViewportView(jTextAreaMessages);

        statusLabel.setText("Ready");

        boardIndexLabel.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
        boardIndexLabel.setText("0");

        jButtonBack.setText("back");
        jButtonBack.setFocusable(false);
        jButtonBack.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jButtonBack.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonBackActionPerformed(evt);
            }
        });

        jButtonForward.setText("forward");
        jButtonForward.setFocusable(false);
        jButtonForward.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jButtonForward.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonForwardActionPerformed(evt);
            }
        });

        jMenuFile.setText("Puzzle");

        jMenuItemNew.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_N, java.awt.event.InputEvent.CTRL_MASK));
        jMenuItemNew.setText("Clear");
        jMenuItemNew.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemNewActionPerformed(evt);
            }
        });
        jMenuFile.add(jMenuItemNew);

        jMenuItemOpen.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_O, java.awt.event.InputEvent.CTRL_MASK));
        jMenuItemOpen.setText("Open");
        jMenuItemOpen.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemOpenActionPerformed(evt);
            }
        });
        jMenuFile.add(jMenuItemOpen);

        jMenuItemSave.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_S, java.awt.event.InputEvent.CTRL_MASK));
        jMenuItemSave.setText("Save");
        jMenuItemSave.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemSaveActionPerformed(evt);
            }
        });
        jMenuFile.add(jMenuItemSave);

        jMenuItemGenerate.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_G, java.awt.event.InputEvent.CTRL_MASK));
        jMenuItemGenerate.setText("Generate");
        jMenuItemGenerate.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemGenerateActionPerformed(evt);
            }
        });
        jMenuFile.add(jMenuItemGenerate);

        jMenuItemGenerateFromInput.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_I, java.awt.event.InputEvent.CTRL_MASK));
        jMenuItemGenerateFromInput.setText("Generate from input");
        jMenuItemGenerateFromInput.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemGenerateFromInputActionPerformed(evt);
            }
        });
        jMenuFile.add(jMenuItemGenerateFromInput);

        PrintMenuItem.setText("Print");
        PrintMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                PrintMenuItemActionPerformed(evt);
            }
        });
        jMenuFile.add(PrintMenuItem);

        jMenuBar1.add(jMenuFile);

        viewMenu.setText("View");

        showCandidatesMenuItem.setText("Show candidates");
        showCandidatesMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                showCandidatesMenuItemActionPerformed(evt);
            }
        });
        viewMenu.add(showCandidatesMenuItem);

        jCheckBoxMenuItemViewTranscript.setText("Show Transcript Window");
        jCheckBoxMenuItemViewTranscript.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxMenuItemViewTranscriptActionPerformed(evt);
            }
        });
        viewMenu.add(jCheckBoxMenuItemViewTranscript);

        highlightChangesCheckBoxMenuItem.setSelected(true);
        highlightChangesCheckBoxMenuItem.setText("Highlight changes");
        highlightChangesCheckBoxMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                highlightChangesCheckBoxMenuItemActionPerformed(evt);
            }
        });
        viewMenu.add(highlightChangesCheckBoxMenuItem);

        jMenuBar1.add(viewMenu);

        jMenuEdit.setText("Edit");

        jMenuItemCopy.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_W, java.awt.event.InputEvent.CTRL_MASK));
        jMenuItemCopy.setText("Copy puzzle");
        jMenuItemCopy.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemCopyActionPerformed(evt);
            }
        });
        jMenuEdit.add(jMenuItemCopy);

        jMenuItemPaste.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_Y, java.awt.event.InputEvent.CTRL_MASK));
        jMenuItemPaste.setText("Paste puzzle");
        jMenuItemPaste.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemPasteActionPerformed(evt);
            }
        });
        jMenuEdit.add(jMenuItemPaste);

        jMenuBar1.add(jMenuEdit);

        jMenuSolver.setText("Solver");

        jMenuItemSolve.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_R, java.awt.event.InputEvent.CTRL_MASK));
        jMenuItemSolve.setText("Solve");
        jMenuItemSolve.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemSolveActionPerformed(evt);
            }
        });
        jMenuSolver.add(jMenuItemSolve);

        jMenuItemCrossEliminate.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_E, java.awt.event.InputEvent.CTRL_MASK));
        jMenuItemCrossEliminate.setText("Eliminate candidates (level 1)");
        jMenuItemCrossEliminate.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemCrossEliminateActionPerformed(evt);
            }
        });
        jMenuSolver.add(jMenuItemCrossEliminate);

        singleDestinationMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_P, java.awt.event.InputEvent.CTRL_MASK));
        singleDestinationMenuItem.setText("Single destination (level 2)");
        singleDestinationMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                singleDestinationMenuItemActionPerformed(evt);
            }
        });
        jMenuSolver.add(singleDestinationMenuItem);

        jMenuItemReduce.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_D, java.awt.event.InputEvent.CTRL_MASK));
        jMenuItemReduce.setText("Reduce");
        jMenuItemReduce.setToolTipText("remove values while maintaining the solution");
        jMenuItemReduce.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemReduceActionPerformed(evt);
            }
        });
        jMenuSolver.add(jMenuItemReduce);

        fixConflictMenuItem.setText("Fix a conflict puzzle");
        fixConflictMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                fixConflictMenuItemActionPerformed(evt);
            }
        });
        jMenuSolver.add(fixConflictMenuItem);

        checkSolvabilityMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_C, java.awt.event.InputEvent.CTRL_MASK));
        checkSolvabilityMenuItem.setText("Check solvability");
        checkSolvabilityMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                checkSolvabilityMenuItemActionPerformed(evt);
            }
        });
        jMenuSolver.add(checkSolvabilityMenuItem);

        jMenuBar1.add(jMenuSolver);

        jMenuStep.setText("Step");

        jMenuItemStepBack.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_B, java.awt.event.InputEvent.CTRL_MASK));
        jMenuItemStepBack.setText("Step back");
        jMenuItemStepBack.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemStepBackActionPerformed(evt);
            }
        });
        jMenuStep.add(jMenuItemStepBack);

        jMenuItemStepForward.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_F, java.awt.event.InputEvent.CTRL_MASK));
        jMenuItemStepForward.setText("Step Forward");
        jMenuItemStepForward.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemStepForwardActionPerformed(evt);
            }
        });
        jMenuStep.add(jMenuItemStepForward);

        jMenuItemGotoStep.setText("Goto step");
        jMenuItemGotoStep.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemGotoStepActionPerformed(evt);
            }
        });
        jMenuStep.add(jMenuItemGotoStep);

        jMenuBar1.add(jMenuStep);

        advancedMenu.setText("Advanced");

        solverRandomSearchCheckBox.setSelected(true);
        solverRandomSearchCheckBox.setText("Solver use random search");
        solverRandomSearchCheckBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                solverRandomSearchCheckBoxActionPerformed(evt);
            }
        });
        advancedMenu.add(solverRandomSearchCheckBox);

        jMenuBar1.add(advancedMenu);

        hintMenu.setText("Assist");

        instantSolvabilityCheckCheckBox.setSelected(true);
        instantSolvabilityCheckCheckBox.setText("Instant quick solvability check");
        instantSolvabilityCheckCheckBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                instantSolvabilityCheckCheckBoxActionPerformed(evt);
            }
        });
        hintMenu.add(instantSolvabilityCheckCheckBox);

        jMenuItem1.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_H, java.awt.event.InputEvent.CTRL_MASK));
        jMenuItem1.setText("Hint one move, please!");
        jMenuItem1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItem1ActionPerformed(evt);
            }
        });
        hintMenu.add(jMenuItem1);

        jMenuBar1.add(hintMenu);

        helpMenu.setText("Help");

        helpMenuItem.setText("Help");
        helpMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                helpMenuItemActionPerformed(evt);
            }
        });
        helpMenu.add(helpMenuItem);

        aboutMenuItem.setText("About");
        aboutMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                aboutMenuItemActionPerformed(evt);
            }
        });
        helpMenu.add(aboutMenuItem);

        jMenuBar1.add(helpMenu);

        setJMenuBar(jMenuBar1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(statusLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 199, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(boardIndexLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jButtonBack)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jButtonForward))
                    .addComponent(tabbedPane, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 232, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(tabbedPane, javax.swing.GroupLayout.PREFERRED_SIZE, 501, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(statusLabel)
                        .addComponent(boardIndexLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 14, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addComponent(jButtonForward)
                    .addComponent(jButtonBack)))
            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 530, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jMenuItemNewActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemNewActionPerformed
//        logMessage("clear puzzle.");
        getSelectedBoardPanel().newBoard();
    }//GEN-LAST:event_jMenuItemNewActionPerformed

    private void jMenuItemSolveActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemSolveActionPerformed
        // only solve from the input board
        if (getSelectedBoardPanel() != inputPanel) {
            showMessageDialog("This can only work from the input tab. Please switch to input tab first.");
            return;
        }
        
        logMessage("Solve puzzle.");
        solve();
    }//GEN-LAST:event_jMenuItemSolveActionPerformed

    private void showCandidatesMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_showCandidatesMenuItemActionPerformed
        setShowCandidates(showCandidatesMenuItem.isSelected());
    }//GEN-LAST:event_showCandidatesMenuItemActionPerformed

    private void jMenuItemOpenActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemOpenActionPerformed
        openFile();
    }//GEN-LAST:event_jMenuItemOpenActionPerformed

    private void jMenuItemCopyActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemCopyActionPerformed
        copy();
    }//GEN-LAST:event_jMenuItemCopyActionPerformed

    private void jMenuItemPasteActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemPasteActionPerformed
        paste();
    }//GEN-LAST:event_jMenuItemPasteActionPerformed

    private void jMenuItemSaveActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemSaveActionPerformed
        saveFile();
    }//GEN-LAST:event_jMenuItemSaveActionPerformed

    private void jMenuItemCrossEliminateActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemCrossEliminateActionPerformed
        if (crossEliminate())
            logMessage("Candidate(s) eliminated.");
        else
            showMessageDialog("No candidate can be eliminated.");
    }//GEN-LAST:event_jMenuItemCrossEliminateActionPerformed

    private void jButtonForwardActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonForwardActionPerformed
        BoardPanel boardPanel = getSelectedBoardPanel();
        if (boardPanel.stepForward()) {
//        	logMessage("step forward, at step " + boardPanel.getBoardHistoryIdx());
        }
    }//GEN-LAST:event_jButtonForwardActionPerformed

    private void jMenuItemReduceActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemReduceActionPerformed
        logMessage("Reduce puzzle.");
        reduce();
    }//GEN-LAST:event_jMenuItemReduceActionPerformed

    private void jMenuItemGenerateActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemGenerateActionPerformed
        generate();
    }//GEN-LAST:event_jMenuItemGenerateActionPerformed

    boolean fixedPanelSet;
    boolean generateFromInput;
    
    private void jMenuItemGenerateFromInputActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemGenerateFromInputActionPerformed
        // only solve from the input board
        if (getSelectedBoardPanel() != inputPanel) {
            showMessageDialog("This can only work from the input tab. Please switch to input tab first.");
            return;
        }
        
        logMessage("generate puzzle from input.");
        generateFromInput();
    }//GEN-LAST:event_jMenuItemGenerateFromInputActionPerformed

	private void jButtonBackActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonBackActionPerformed
        BoardPanel boardPanel = getSelectedBoardPanel();
        if (boardPanel.stepBack()) {
//            logMessage("step back, at step " + boardPanel.getBoardHistoryIdx());
        }
    }//GEN-LAST:event_jButtonBackActionPerformed

    private void tabbedPaneStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_tabbedPaneStateChanged
        assignLabelsToSelectedPanel();
    }//GEN-LAST:event_tabbedPaneStateChanged

    private void jMenuItemStepBackActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemStepBackActionPerformed
        jButtonBackActionPerformed(evt);
    }//GEN-LAST:event_jMenuItemStepBackActionPerformed

    private void jMenuItemStepForwardActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemStepForwardActionPerformed
        jButtonForwardActionPerformed(evt);
    }//GEN-LAST:event_jMenuItemStepForwardActionPerformed

    private void jMenuItemGotoStepActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemGotoStepActionPerformed
        BoardPanel boardPanel = getSelectedBoardPanel();
        int idx = Integer.parseInt( JOptionPane.showInputDialog("enter step number", boardPanel.getBoardHistoryIdx() ) );
        if (idx < 0 || idx >= boardPanel.getBoardHistorySize()) {
            showMessageDialog( "must be within " + 0 + " to " + boardPanel.getBoardHistorySize() );
            return;
        }
        boardPanel.setStep(idx);
    }//GEN-LAST:event_jMenuItemGotoStepActionPerformed

    private void jCheckBoxMenuItemViewTranscriptActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxMenuItemViewTranscriptActionPerformed
        showTranscriptWindow(jCheckBoxMenuItemViewTranscript.isSelected());
    }//GEN-LAST:event_jCheckBoxMenuItemViewTranscriptActionPerformed

    boolean solverRandomSearch = true;

    private void solverRandomSearchCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_solverRandomSearchCheckBoxActionPerformed
        solverRandomSearch = solverRandomSearchCheckBox.isSelected();
    }//GEN-LAST:event_solverRandomSearchCheckBoxActionPerformed

    private void instantSolvabilityCheckCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_instantSolvabilityCheckCheckBoxActionPerformed
        instantSolvabilityCheck = instantSolvabilityCheckCheckBox.isSelected();
    }//GEN-LAST:event_instantSolvabilityCheckCheckBoxActionPerformed

    private void aboutMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_aboutMenuItemActionPerformed
        // pop out a dialog
        JDialog aboutDialog = new AboutDialog(this, true);

        Point point = getLocationProperty("aboutDialog");
        if (point!=null)
            aboutDialog.setLocation(point);
        aboutDialog.setVisible(true);

        saveLocationSetting("aboutDialog", aboutDialog);
        aboutDialog.dispose();
    }//GEN-LAST:event_aboutMenuItemActionPerformed

    private void jMenuItem1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItem1ActionPerformed
        hintOneMove();
    }//GEN-LAST:event_jMenuItem1ActionPerformed

    private void formWindowClosing(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowClosing
        // save window location
        saveLocationSetting(windowName, this);

        saveLocationSetting("transcriptWindow", transcriptWindow);

        saveProperties();
        
    }//GEN-LAST:event_formWindowClosing

    private void singleDestinationMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_singleDestinationMenuItemActionPerformed
        if (singleDestination()) {
            logMessage("SingleDestination found.");

        } else
            showMessageDialog("no SingleDestination can be found - try eliminate candidates first.");
    }//GEN-LAST:event_singleDestinationMenuItemActionPerformed

    private void helpMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_helpMenuItemActionPerformed
        // pop out a dialog
        EditorPaneDialog helpDialog = new EditorPaneDialog(this, true);
        helpDialog.setPageHtmlURL("/org/gu/junyang/solver/sudoku/gui/resources/help.html");
        Point point = getLocationProperty("helpDialog");
        if (point!=null)
            helpDialog.setLocation(point);
        helpDialog.setVisible(true);

        saveLocationSetting("helpDialog", helpDialog);
        helpDialog.dispose();
    }//GEN-LAST:event_helpMenuItemActionPerformed

    private void fixConflictMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_fixConflictMenuItemActionPerformed
        Puzzle puzzle;
        try {
            puzzle = new Sudoku().fixConflictPuzzle(getSelectedBoard().getPuzzle());
        } catch (ProgramErrorException ex) {
            showProgramErrorExceptionDialog(ex);
//            java.util.logging.Logger.getLogger(MainWindow.class.getName()).log(Level.SEVERE, null, ex);
            return;
        }
        logMessage("Fixed puzzle. Please check whether the fixed puzzle has multiple solutions.");
        fixedPanel.setNewBoard(new Board(puzzle));
        tabbedPane.setSelectedComponent(fixedPanel);

    }//GEN-LAST:event_fixConflictMenuItemActionPerformed

    private void PrintMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_PrintMenuItemActionPerformed
        PrinterJob job = PrinterJob.getPrinterJob();
//        PrintRequestAttributeSet aset = new HashPrintRequestAttributeSet();
//        PageFormat pageFormat = job.pageDialog(aset);
        PageFormat pageFormat = job.pageDialog(job.defaultPage());
        job.setPrintable(getSelectedBoardPanel(), pageFormat);
//        job.setPrintable(getSelectedBoardPanel());
        boolean ok = job.printDialog();
        if (ok) {
            try {
                job.print();
            } catch (PrinterException ex) {
                showMessageDialog("PrinterException: " + ex.getMessage());
                return;
            }
            showMessageDialog("The page has been sent to the printer.");
        }
    }//GEN-LAST:event_PrintMenuItemActionPerformed

    private void checkSolvabilityMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_checkSolvabilityMenuItemActionPerformed
        SolveResult solveResult;
        if (showCandidates)
            try {
            solveResult = new Sudoku().isSolvable(getSelectedBoard());
        } catch (ProgramErrorException ex) {
            showProgramErrorExceptionDialog(ex);
//            java.util.logging.Logger.getLogger(MainWindow.class.getName()).log(Level.SEVERE, null, ex);
            return;
        }
        else
            try {
            solveResult = new Sudoku().isSolvable(getSelectedBoard().getPuzzle());
        } catch (ProgramErrorException ex) {
            showProgramErrorExceptionDialog(ex);
//            java.util.logging.Logger.getLogger(MainWindow.class.getName()).log(Level.SEVERE, null, ex);
            return;
        }
        String msg;
        if (solveResult == SolveResult.SOLVED)
            msg = "It is solvable.";
        else if (solveResult == SolveResult.UNSOLVABLE)
            msg = "It is NOT solvable.";
        else // if (solveResult == SolveResult.SOLVED_MULTIPLE_SOLUTIONS)
            msg = "It is solvable, but has MULTIPLE solutions.";
        showMessageDialog(msg);
    }//GEN-LAST:event_checkSolvabilityMenuItemActionPerformed

    private void highlightChangesCheckBoxMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_highlightChangesCheckBoxMenuItemActionPerformed
        for (Component c : tabbedPane.getComponents()) {
            ( (BoardPanel)c ).setHighlightChanges(highlightChangesCheckBoxMenuItem.isSelected());
        }
    }//GEN-LAST:event_highlightChangesCheckBoxMenuItemActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        java.awt.EventQueue.invokeLater(new Runnable() {

            public void run() {
                new MainWindow().setVisible(true);
            }
        });
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JMenuItem PrintMenuItem;
    private javax.swing.JMenuItem aboutMenuItem;
    private javax.swing.JMenu advancedMenu;
    private javax.swing.JLabel boardIndexLabel;
    private javax.swing.JMenuItem checkSolvabilityMenuItem;
    private javax.swing.JMenuItem fixConflictMenuItem;
    private org.gu.junyang.solver.sudoku.gui.BoardPanel fixedPanel;
    private org.gu.junyang.solver.sudoku.gui.BoardPanel guessPanel;
    private javax.swing.JMenu helpMenu;
    private javax.swing.JMenuItem helpMenuItem;
    private javax.swing.JCheckBoxMenuItem highlightChangesCheckBoxMenuItem;
    private javax.swing.JMenu hintMenu;
    private org.gu.junyang.solver.sudoku.gui.BoardPanel inputPanel;
    private javax.swing.JCheckBoxMenuItem instantSolvabilityCheckCheckBox;
    private javax.swing.JButton jButtonBack;
    private javax.swing.JButton jButtonForward;
    private javax.swing.JCheckBoxMenuItem jCheckBoxMenuItemViewTranscript;
    private javax.swing.JMenuBar jMenuBar1;
    private javax.swing.JMenu jMenuEdit;
    private javax.swing.JMenu jMenuFile;
    private javax.swing.JMenuItem jMenuItem1;
    private javax.swing.JMenuItem jMenuItemCopy;
    private javax.swing.JMenuItem jMenuItemCrossEliminate;
    private javax.swing.JMenuItem jMenuItemGenerate;
    private javax.swing.JMenuItem jMenuItemGenerateFromInput;
    private javax.swing.JMenuItem jMenuItemGotoStep;
    private javax.swing.JMenuItem jMenuItemNew;
    private javax.swing.JMenuItem jMenuItemOpen;
    private javax.swing.JMenuItem jMenuItemPaste;
    private javax.swing.JMenuItem jMenuItemReduce;
    private javax.swing.JMenuItem jMenuItemSave;
    private javax.swing.JMenuItem jMenuItemSolve;
    private javax.swing.JMenuItem jMenuItemStepBack;
    private javax.swing.JMenuItem jMenuItemStepForward;
    private javax.swing.JMenu jMenuSolver;
    private javax.swing.JMenu jMenuStep;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTextArea jTextAreaMessages;
    private org.gu.junyang.solver.sudoku.gui.BoardPanel reducedPanel;
    private javax.swing.JCheckBoxMenuItem showCandidatesMenuItem;
    private javax.swing.JMenuItem singleDestinationMenuItem;
    private org.gu.junyang.solver.sudoku.gui.BoardPanel solutionPanel;
    private javax.swing.JCheckBoxMenuItem solverRandomSearchCheckBox;
    private javax.swing.JLabel statusLabel;
    private javax.swing.JTabbedPane tabbedPane;
    private javax.swing.JMenu viewMenu;
    // End of variables declaration//GEN-END:variables

    private void customInitComponents() {
    	PropertyConfigurator.configure("log4j.properties");
    	
//        getContentPane().add(new BoardPanel());

        inputPanel.setEditable(true);
        inputPanel.setParent(this);

        inputPanel.setInstantSanityCheck(true);

        inputPanel.setEnableBoardHistory(true);
        inputPanel.setEnablePatternCellLists();

        inputPanel.setShowDialogUponSolved(true);

        inputPanel.newBoard();

        solutionPanel.setEnableBoardHistory(true);
        solutionPanel.setBoardHistorySizeLimit(0);      // no limit
        solutionPanel.newBoard();
        
        guessPanel.setEnableBoardHistory(true);
        guessPanel.newBoard();

        fixedPanel.setEnableBoardHistory(true);
        fixedPanel.newBoard();

        reducedPanel.setEnableBoardHistory(true);
        reducedPanel.newBoard();

        assignLabelsToSelectedPanel();

        createTranscriptWindow();

        statusLabel.setOpaque(true);
        
//        setResizable(false);

        pack();

        // restoreSettings
        Point point = getLocationProperty(windowName);
        if (point!=null)
            setLocation(point);

        logger.info("window size: " + getWidth() + " " + getHeight());
    }

    private void solve() {
        fixedPanelSet = false;

        saveAndShowWaitCursor();

        // use the non-greedy solver for better progress showing
        SolverFactory.setSolverClassName(SolverFactory.SolverNonGreedyClassName);
        Sudoku sudoku = new Sudoku();
        SolverFactory.setSolverClassName(SolverFactory.SolverDefaultClassName);

        sudoku.setRecordTranscript(true);
        sudoku.setRecordBoardHistory(true);
        sudoku.setRandomSearch(solverRandomSearch);				// use random search

        Sudoku.SolveResult solveResult;
        
        if (showCandidates && !generateFromInput)
        	solveResult = sudoku.solve( new Board(inputPanel.getBoard() ) );
        else
        	solveResult = sudoku.solve( inputPanel.getBoard().getPuzzle() );

        int transcriptSolutionIndex;

        int boardHistorySolutionIndex;

        if (solveResult == SolveResult.UNSOLVABLE) {
            showMessageDialog(sudoku.getMessage());
            boardHistorySolutionIndex = sudoku.getBoardHistory().size()-1;
            transcriptSolutionIndex = sudoku.getTranscript().size()-1;
        } else if (solveResult == SolveResult.UNSOLVED) {
            showMessageDialog("unsolvable.");
            boardHistorySolutionIndex = sudoku.getBoardHistory().size()-1;
            transcriptSolutionIndex = sudoku.getTranscript().size()-1;
        } else {
            // solved
            int level = sudoku.getLevel();

            String message = "solved: capability level: " + level;

            // check multiple puzzle
            if ( solveResult == SolveResult.SOLVED_MULTIPLE_SOLUTIONS ) {
                if (!generateFromInput)
                    message += NL + "WARNING: Multiple solutions found. See the fixed tab for corrected puzzle (input + guessed).";

                // prepare guess board
                Board guessBoard = new Board();
                guessBoard.read(new Scanner(sudoku.getGuessBoards().get(0)));
                guessPanel.setNewBoard(guessBoard);

                // prepare generated board
                Puzzle puzzle = inputPanel.getBoard().getPuzzle();
                try {
                    puzzle.combine(new Puzzle(sudoku.getGuessBoards().get(0)));
                } catch (UnexpectedEndOfInputException ex) {
                    java.util.logging.Logger.getLogger(MainWindow.class.getName()).log(Level.SEVERE, null, ex);
                    showMessageDialog("program error.");
                    return;
                }

                fixedPanel.setNewBoard(new Board(puzzle));
                fixedPanelSet = true;
            }

            System.out.println(message);

            showMessageDialog(message);

            boardHistorySolutionIndex = sudoku.getSolutionBoardIndexes().get(0);
            transcriptSolutionIndex = sudoku.getSolutionTranscriptIndexes().get(0);
        }

        ArrayList<Board> boardHistory = sudoku.getBoardHistory();
        ArrayListUtils.removeTailStartingAt(boardHistory, boardHistorySolutionIndex+1);
        solutionPanel.setBoardHistory(boardHistory, sudoku.getPatternCellLists());
        
//        System.err.println("board history solution at: " + boardHistorySolutionIndex );

        solutionPanel.setStep(boardHistorySolutionIndex);

        setTranscriptAndActions(sudoku.getTranscript(), sudoku.getBoardHistoryTranscriptIdxs(), transcriptSolutionIndex);

        if (solveResult != SolveResult.UNSOLVABLE)
        	tabbedPane.setSelectedComponent(solutionPanel);

        restoreCursor();
    }

    private void generateFromInput() {
        generateFromInput = true;
        solve();
        generateFromInput = false;
        if (!fixedPanelSet) {
            showMessageDialog("Nothing to generate - the input puzzle is already complete.");
            return;
        }
        tabbedPane.setSelectedComponent(fixedPanel);
	}

    boolean showCandidates;

    private void setShowCandidates(boolean showCandidates) {
        this.showCandidates = showCandidates;
        
        for (Component c : tabbedPane.getComponents()) {
            ( (BoardPanel)c ).setShowCandidates(showCandidates);
        }
    }
    
    File previousDirectory = null;
    String previousFileName = null;

    private void openFile() {
//        newBoard();

        File file = chooseOpenFile();
        if (file == null) {
            return;
        }
        previousFileName = file.getName();

        logMessage("Opened file: " + file.getName());

        Scanner scanner;
        try {
            scanner = new Scanner(file);
        } catch (FileNotFoundException ex) {
            java.util.logging.Logger.getLogger(MainWindow.class.getName()).log(Level.SEVERE, null, ex);
            return;
        }

        inputPanel.read(scanner);
        
        tabbedPane.setSelectedComponent(inputPanel);
    }

	void showMessageDialog(String message) {
        JOptionPane.showMessageDialog(this, message);
        logMessage(message);
    }

    private File chooseOpenFile() {
        JFileChooser fc = getFileChooser();

        //In response to a button click:
        int returnVal = fc.showOpenDialog(this);
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            // save current directory
            previousDirectory = fc.getCurrentDirectory();
            return fc.getSelectedFile();
        } else {
            return null;
        }
    }

    private File chooseSaveFile() {
        JFileChooser fc = getFileChooser();

        //In response to a button click:
        int returnVal = fc.showSaveDialog(this);
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            // save current directory
            previousDirectory = fc.getCurrentDirectory();
            return fc.getSelectedFile();
        } else {
            return null;
        }
    }

    private JFileChooser getFileChooser() {
        final JFileChooser fc = new JFileChooser();
        if (previousDirectory == null) {
            fc.setCurrentDirectory(new File(System.getProperties().getProperty("user.dir")));
        } else {
            fc.setCurrentDirectory(previousDirectory);
        }
        return fc;
    }

    private void saveFile() {
        File file = chooseSaveFile();
        if (file == null) {
            return;
        }

        logMessage("Saved file: " + file.getName());

        PrintStream out;
        try {
            out = new PrintStream(new FileOutputStream(file));
        } catch (FileNotFoundException ex) {
            java.util.logging.Logger.getLogger(MainWindow.class.getName()).log(Level.SEVERE, null, ex);
            showMessageDialog("FileNotFoundException: " + ex.getMessage());
            return;
        }

        Board board = getSelectedBoard();
        if (board == null) {
            out.println(jTextAreaMessages.getText());
        } else {
            out.println(board.toSimpleString());
        }
    }

    private BoardPanel getSelectedBoardPanel() {
//        if (jTabbedPane1.getSelectedComponent() == inputPanel) {
//            return inputPanel;
//        } else if (jTabbedPane1.getSelectedComponent() == solutionPanel) {
//            return solutionPanel;
//        } else if (jTabbedPane1.getSelectedComponent() == guessPanel) {
//            return guessPanel;
//        } else if (jTabbedPane1.getSelectedComponent() == boardPanelReduced) {
//            return boardPanelReduced;
//        } else if (jTabbedPane1.getSelectedComponent() == boardPanelGenerated) {
//            return boardPanelGenerated;
//        } else {
//            return null;
//        }
        return (BoardPanel) tabbedPane.getSelectedComponent();
    }

    private Board getSelectedBoard() {
        BoardPanel boardPanel = getSelectedBoardPanel();
        return boardPanel.getBoard();
//        if (boardPanel != null) {
//            return boardPanel.getBoard();
//        } else {
//            return null;
//        }
    }

    void logMessage(String message) {
        jTextAreaMessages.append(message + NL);
    }

    private void reduce() {
        saveAndShowWaitCursor();
        Board board = new Board( getSelectedBoard() );
        Sudoku sudoku = new Sudoku();
        sudoku.setRandomSearch(solverRandomSearch);

        try {
            board = sudoku.reduce(board.getPuzzle());
        } catch (ProgramErrorException ex) {
            showProgramErrorExceptionDialog(ex);
//            java.util.logging.Logger.getLogger(MainWindow.class.getName()).log(Level.SEVERE, null, ex);
            restoreCursor();
            return;
        }

        if (sudoku.getReductionCount() > 0) {
            logMessage("reduced " + sudoku.getReductionCount() + " values.");
            reducedPanel.setNewBoard(board);
            tabbedPane.setSelectedComponent(reducedPanel);
        } else {
            logMessage("Not reduceable.");
        }
        restoreCursor();
    }

    public void PostMessage(String message) {
        logMessage(message);
    }

    private void copy() {
        Clipboard clipboard = getToolkit().getSystemClipboard();
        Board board = getSelectedBoard();
        if (board != null) {
            Puzzle puzzle = board.getPuzzle();
            clipboard.setContents(puzzle, null);
            logMessage("Puzzle copied.");
        } else {
            showMessageDialog("No Sudoku board is selected.");
        }
    }

    private void paste() {
        Clipboard clipboard = getToolkit().getSystemClipboard();
        Puzzle puzzle;
        try {
            Object object = clipboard.getData(Puzzle.dataFlavor);
            String puzzleStr = (String) object;
            puzzle = new Puzzle(puzzleStr);
        } catch (UnsupportedFlavorException ex) {
//            java.util.logging.Logger.getLogger(MainWindow.class.getName()).log(Level.SEVERE, null, ex);
            showMessageDialog("UnsupportedFlavorException: " + ex.getMessage());
            return;
        } catch (IOException ex) {
//            java.util.logging.Logger.getLogger(MainWindow.class.getName()).log(Level.SEVERE, null, ex);
            showMessageDialog("IOException: " + ex.getMessage());
            return;
        } catch (UnexpectedEndOfInputException ex) {
//            java.util.logging.Logger.getLogger(MainWindow.class.getName()).log(Level.SEVERE, null, ex);
            showMessageDialog("unexpected end of input from clipboard: " + ex.getMessage());
            return;
        }

        Board board = getSelectedBoard();
        if (board != null) {
            getSelectedBoardPanel().setNewBoard(new Board(puzzle));
            logMessage("Puzzle pasted.");
        } else {
            showMessageDialog("No Sudoku board is selected.");
        }
    }

    private boolean crossEliminate() {
        Board board = getSelectedBoard();
        
        SolverNonGreedy solver = new SolverNonGreedy();
        solver.setRecordBoardHistory(true);
        solver.setBoard(board);
        boolean eliminated = solver.CrossEliminateAll();

        if (eliminated) {
            BoardPanel boardPanel = getSelectedBoardPanel();
            boardPanel.setNewBoard(solver.getBoard(), solver.getPatternCellList());
        }

        return eliminated;
    }

    private boolean singleDestination() {
        Board board = getSelectedBoard();

        SolverNonGreedy solver = new SolverNonGreedy();
        solver.setRecordBoardHistory(true);
        solver.setBoard(board);

        if (solver.singleDestinationAll()) {
        	board = solver.getBoard();
            BoardPanel boardPanel = getSelectedBoardPanel();
            boardPanel.setNewBoard(board, solver.getPatternCellList());
            return true;
        } else
            return false;
    }

    Cursor savedCursor;

    // a dialog to block all inputs
    JDialog waitDialog;

    private void generate() {
        GenerateJDialog generateJDialog = new GenerateJDialog(this, true);

        Point point = getLocationProperty("generateJDialog");
        if (point!=null)
            generateJDialog.setLocation(point);
        generateJDialog.setVisible(true);

        saveLocationSetting("generateJDialog", generateJDialog);
        generateJDialog.dispose();

        if (!generateJDialog.confirmed) {
            return;
        }

        saveAndShowWaitCursor();
        
//        getGlassPane().setVisible(true);

        String message = "Generate puzzle";

//        System.out.println("random " + generateJDialog.getjRadioButtonRandom().isSelected());
//        System.out.println("puzzle ID " + generateJDialog.getjTextFieldPuzzleId().getText());
//        System.out.println("specify level " + generateJDialog.getjCheckBoxSpecifyLevel().isSelected());
//        System.out.println("level " + (generateJDialog.getjComboBoxLevel().getSelectedIndex() + 1));

//        Sudoku sudoku = new Sudoku();
        boolean random = generateJDialog.getjRadioButtonRandom().isSelected();
        long seed = Long.parseLong(generateJDialog.getjTextFieldPuzzleId().getText());

        if (random) {
            message += ", random";
        } else {
            message += ", seed = " + seed;
        }

        Integer level;
        String dialogMessage;
        if (generateJDialog.getjCheckBoxSpecifyLevel().isSelected()) {
            level = (generateJDialog.getjComboBoxLevel().getSelectedIndex() + 1);
            message += ", level = " + level;
            dialogMessage = "searching...";
        } else {
            level = null;
            dialogMessage = "generating...";
        }

        logMessage(message);

        SudokuWorker sudokuWorker = new SudokuWorker(random, seed, level, this, this);
        sudokuWorker.execute();

        createAndShowWaitDialog(dialogMessage);

        if (!sudokuWorker.isDone()) {
            System.err.println("cancel worker: " + sudokuWorker.cancel(true));
            logMessage("cancel puzzle generation.");
            restoreCursor();
        }

    }

    // for sudokuWorker call back
    public void updateInputPanel(Board board) {
        inputPanel.setNewBoard(board);
        tabbedPane.setSelectedComponent(inputPanel);
    }

    public void saveAndShowWaitCursor() {
        savedCursor = getCursor();
        setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
    }
    
    public void restoreCursor() {
        setCursor(savedCursor);
//        getGlassPane().setVisible(false);
    }

    private void createTranscriptWindow() {
        transcriptWindow = new TextAreaDialog(this, false);
        transcriptWindow.setCheckBoxMenuItem(jCheckBoxMenuItemViewTranscript);
        transcriptWindow.pack();

        Point point = getLocationProperty("transcriptWindow");
        if (point!=null)
            transcriptWindow.setLocation(point);
    }

    private void showTranscriptWindow(boolean show) {
        transcriptWindow.setVisible(show);
    }

	public void setInstantSolvabilityCheck(boolean instantSolvabilityCheck) {
		this.instantSolvabilityCheck = instantSolvabilityCheck;
	}
    
    private void hintOneMove() {
    	tabbedPane.setSelectedComponent(inputPanel);
    	
        saveAndShowWaitCursor();

        Board board = new Board( inputPanel.getBoard() );

        // use the non-greedy solver for better progress showing
        SolverFactory.setSolverClassName(SolverFactory.SolverNonGreedyClassName);
        Sudoku sudoku = new Sudoku();
        SolverFactory.setSolverClassName(SolverFactory.SolverDefaultClassName);
        
        sudoku.setRecordTranscript(true);
        sudoku.setRecordBoardHistory(true);
        sudoku.setRandomSearch(solverRandomSearch);				// use random search
        sudoku.setFindAllSolutions(false);
        sudoku.solve(board);

        if (sudoku.getBoardHistory().size()<2) {
        	showMessageDialog("unable to find a move");
        	restoreCursor();
        	return;
        }
        
        // find the first setvalue
        int transcriptSolutionIndex = sudoku.getBoardHistoryTranscriptIdxs().get(1);

        // set the transcript
        setTranscriptAndActions(sudoku.getTranscript(), sudoku.getBoardHistoryTranscriptIdxs(), transcriptSolutionIndex);

        // set the board
        inputPanel.setNewBoard(sudoku.getBoardHistory().get(1), sudoku.getPatternCellLists().get(1));
        
        restoreCursor();
        
        // focus back to the main window
//        setVisible(true);
    }

    private void setTranscriptAndActions(ArrayList<String> transcript, ArrayList<Integer> boardHistoryTranscriptIdxs, int transcriptSolutionIndex) {
        int cnt = 1;
        JTextArea textArea = transcriptWindow.getjTextArea1();
        textArea.setText("");
        int cnt2 = 1;
        int bhtiIdx=1;
        for (int i = 0; i <= transcriptSolutionIndex; i++) {
            if ( i==boardHistoryTranscriptIdxs.get(bhtiIdx) ) {
            	bhtiIdx++;
                textArea.append(Integer.toString(cnt++) + ": " + transcript.get(i) + NL);
                cnt2=1;
            } else {
                textArea.append(Integer.toString(cnt) + "-" + cnt2++ + ": " + transcript.get(i) + NL);
            }
        }
    }

    private void assignLabelsToSelectedPanel() {
        for (Component c : tabbedPane.getComponents()) {
            BoardPanel p = (BoardPanel) c;
            if (p==tabbedPane.getSelectedComponent()) {
                p.setStatusLabel(statusLabel);
                p.setBoardHistoryIdxLabel(boardIndexLabel);
            } else {
                p.setStatusLabel(null);
                p.setBoardHistoryIdxLabel(null);
            }
        }
    }

    private void createAndShowWaitDialog(String dialogMessage) {
        String[] options = {"cancel"};

        // pop up a dialog to block key input to the main window

        final JOptionPane jOptionPane = new JOptionPane(dialogMessage, JOptionPane.INFORMATION_MESSAGE, JOptionPane.DEFAULT_OPTION, null, options);
        waitDialog = new JDialog(this, "generate puzzle", true);
        waitDialog.setContentPane(jOptionPane);

        jOptionPane.addPropertyChangeListener(
                new PropertyChangeListener() {

                    public void propertyChange(PropertyChangeEvent e) {
                        String prop = e.getPropertyName();

                        if (waitDialog.isVisible()
                                && (e.getSource() == jOptionPane)
                                && (prop.equals(JOptionPane.VALUE_PROPERTY))) {
                            //If you were going to check something
                            //before closing the window, you'd do
                            //it here.
//                            jDialog.setVisible(false);
                            waitDialog.dispose();
                        }
                    }
                });

        waitDialog.pack();

        waitDialog.setLocation( getOffSetLocation(this, 100, 100) );

        waitDialog.setVisible(true);
    }

    private void readProperties() {
        try {
            // read properties if any
            properties.load(new FileReader(propertiesFileFullPathName));
        } catch (FileNotFoundException ex) {
//            java.util.logging.Logger.getLogger(MainWindow.class.getName()).log(Level.SEVERE, null, ex);
            logger.info("no properties file found.");
            return;
        } catch (IOException ex) {
//            java.util.logging.Logger.getLogger(MainWindow.class.getName()).log(Level.SEVERE, null, ex);
            logger.info("unable to read the properties file.");
            return;
        }
    }

    private Point getLocationProperty(String windowName) {
        try {
            Point point = new Point( Integer.parseInt(properties.getProperty(windowName+" locationX")),
                Integer.parseInt(properties.getProperty(windowName+" locationY")) );
            return point;
        } catch (NumberFormatException ex) {
            logger.error("NumberFormatException");
            return null;
        }
    }

    private void saveLocationSetting(String windowName, Component frame) {
        properties.setProperty( windowName + " locationX", Integer.toString((int) frame.getLocation().getX()) );
        properties.setProperty( windowName + " locationY", Integer.toString((int) frame.getLocation().getY()) );
    }

    private void saveProperties() {
        try {
            // save settings
            properties.store(new FileWriter(propertiesFileFullPathName), "jisudokusolver settings");
        } catch (IOException ex) {
//            java.util.logging.Logger.getLogger(MainWindow.class.getName()).log(Level.SEVERE, null, ex);
            logger.error("error writing properties file");
        }
    }

    private Point getOffSetLocation(Component component, int xOffset, int yOffset) {
        Point point= component.getLocation();
        point.setLocation(point.x + xOffset , point.y + yOffset);
        return point;
    }

    private void showProgramErrorExceptionDialog(ProgramErrorException ex) {
        logger.error(ex.getMessage());
        showMessageDialog(ex.getMessage() + NL + ExceptionUtils.getStackTraceString(ex));
    }

    
}
